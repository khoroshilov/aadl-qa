PACKAGE deploymentview::DV
PUBLIC
WITH Deployment;
WITH Taste;

WITH interfaceview::IV;

WITH ocarina_buses;
WITH ocarina_drivers;
WITH ocarina_processors_leon;
WITH ocarina_processors_x86;
 
---------------------------------------------------
-- TASTE Deployement View 
---------------------------------------------------

  ----------------------
  -- ProcessorBoards --
  ----------------------

  SYSTEM linuxboard_obj80
    FEATURES
      obj256_serialaccess : requires bus access ocarina_buses::serial.generic
        { Taste::Coordinates => "82 83"; };
  END linuxboard_obj80;

  PROCESS mypart_obj168
  END mypart_obj168;

  PROCESS IMPLEMENTATION mypart_obj168.others
  END mypart_obj168.others;

  MEMORY ram_obj212
  END ram_obj212;

  MEMORY IMPLEMENTATION ram_obj212.others
  END ram_obj212.others;

  DEVICE serialdriversender_obj256 EXTENDS ocarina_drivers::generic_serial
    PROPERTIES
      Taste::Coordinates => "82 83" applies to serialaccess;
      Taste::Interface_Coordinates => "87 112" applies to serialaccess;
      Deployment::Configuration => "{devname ""/dev/ttyS0"", speed b38400}";
  END serialdriversender_obj256;

  DEVICE IMPLEMENTATION serialdriversender_obj256.others EXTENDS ocarina_drivers::generic_serial.raw_sender
  END serialdriversender_obj256.others;

  SYSTEM IMPLEMENTATION linuxboard_obj80.others
    SUBCOMPONENTS
      mypart_obj168 : PROCESS mypart_obj168.others
        { Taste::Coordinates => "11 17 80 45";
           Deployment::Port_Number => 0;};
      pinger_obj355 : SYSTEM interfaceview::IV::pinger
        { Taste::Coordinates => "13 24 73 40" ;};
      linuxnative_obj124 : PROCESSOR ocarina_processors_x86::x86.linux32
        { Taste::Coordinates => "8 9 84 49"; };
      ram_obj212 : MEMORY ram_obj212.others
        { Taste::Coordinates => "7 51 83 64"; };
      serialdriversender_obj256 : DEVICE serialdriversender_obj256.others
        { Taste::Coordinates => "8 67 84 83";};

    CONNECTIONS
      --  The bus connections
      BUS ACCESS obj256_serialaccess -> serialdriversender_obj256.serialaccess;

    PROPERTIES
      -- Connexion des CPUs aux process/drivers
      Actual_Processor_Binding => (reference (linuxnative_obj124)) applies to mypart_obj168;
      Taste::APLC_Binding => (reference(mypart_obj168)) APPLIES TO pinger_obj355;
      Actual_Processor_Binding => (reference (linuxnative_obj124)) applies to serialdriversender_obj256;
      Actual_Memory_Binding => (reference (ram_obj212)) applies to mypart_obj168;
  END linuxboard_obj80.others;

  --{ leoncentral_obj91 obj591 142 10 
  --This board runs with the FPGA.
  --Should have spw addr 22
  --}

  SYSTEM leoncentral_obj91
    FEATURES
      obj267_serialaccess : requires bus access ocarina_buses::serial.generic
        { Taste::Coordinates => "116 75"; };
      obj278_spwaccess : requires bus access ocarina_buses::spacewire.generic
        { Taste::Coordinates => "164 94"; };
  END leoncentral_obj91;

  PROCESS mypart_obj179
  END mypart_obj179;

  PROCESS IMPLEMENTATION mypart_obj179.others
  END mypart_obj179.others;

  MEMORY ram_obj223
  END ram_obj223;

  MEMORY IMPLEMENTATION ram_obj223.others
  END ram_obj223.others;

  DEVICE serial_obj267 EXTENDS ocarina_drivers::rasta_serial
    PROPERTIES
      Taste::Coordinates => "116 75" applies to serialaccess;
      Taste::Interface_Coordinates => "112 112" applies to serialaccess;
      Deployment::Configuration => "{devname ""/dev/apburasta0"", speed b38400}";
  END serial_obj267;

  DEVICE IMPLEMENTATION serial_obj267.others EXTENDS ocarina_drivers::rasta_serial.raw
  END serial_obj267.others;

  DEVICE spw_obj278 EXTENDS ocarina_drivers::rasta_spacewire
    PROPERTIES
      Taste::Coordinates => "164 94" applies to spwaccess;
      Taste::Interface_Coordinates => "169 114" applies to spwaccess;
      Deployment::Configuration => "{devname ""/dev/grspwrasta0"", nodeaddr 22, corefreq 30000}";
  END spw_obj278;

  DEVICE IMPLEMENTATION spw_obj278.others EXTENDS ocarina_drivers::rasta_spacewire.pohic
  END spw_obj278.others;

  --{ leoncentral_obj91 obj591 142 10 
  --This board runs with the FPGA.
  --Should have spw addr 22
  --}

  SYSTEM IMPLEMENTATION leoncentral_obj91.others
    SUBCOMPONENTS
      mypart_obj179 : PROCESS mypart_obj179.others
        { Taste::Coordinates => "118 20 172 42";
           Deployment::Port_Number => 0;};
      pingee1_obj366 : SYSTEM interfaceview::IV::pingee1
        { Taste::Coordinates => "123 28 167 38" ;};
      leoncpu_obj135 : PROCESSOR ocarina_processors_leon::leon.rtems
        { Taste::Coordinates => "113 14 178 46"; };
      ram_obj223 : MEMORY ram_obj223.others
        { Taste::Coordinates => "115 51 177 67"; };
      serial_obj267 : DEVICE serial_obj267.others
        { Taste::Coordinates => "116 70 177 82";};
      spw_obj278 : DEVICE spw_obj278.others
        { Taste::Coordinates => "113 85 173 94";};

    CONNECTIONS
      --  The bus connections
      BUS ACCESS obj267_serialaccess -> serial_obj267.serialaccess;
      BUS ACCESS obj278_spwaccess -> spw_obj278.spwaccess;

    PROPERTIES
      -- Connexion des CPUs aux process/drivers
      Actual_Processor_Binding => (reference (leoncpu_obj135)) applies to mypart_obj179;
      Taste::APLC_Binding => (reference(mypart_obj179)) APPLIES TO pingee1_obj366;
      Actual_Processor_Binding => (reference (leoncpu_obj135)) applies to serial_obj267;
      Actual_Processor_Binding => (reference (leoncpu_obj135)) applies to spw_obj278;
      Actual_Memory_Binding => (reference (ram_obj223)) applies to mypart_obj179;
  END leoncentral_obj91.others;

  --{ leonfinal_obj102 obj602 242 10 
  --This is the single board without FPGA, should 
  --have spw address 10
  --}

  SYSTEM leonfinal_obj102
    FEATURES
      obj289_spwaccess : requires bus access ocarina_buses::spacewire.generic
        { Taste::Coordinates => "210 78"; };
      obj300_serialaccess : requires bus access ocarina_buses::serial.generic
        { Taste::Coordinates => "267 104"; };
  END leonfinal_obj102;

  PROCESS mypart_obj190
  END mypart_obj190;

  PROCESS IMPLEMENTATION mypart_obj190.others
  END mypart_obj190.others;

  MEMORY ram_obj234
  END ram_obj234;

  MEMORY IMPLEMENTATION ram_obj234.others
  END ram_obj234.others;

  DEVICE spw_obj289 EXTENDS ocarina_drivers::rasta_spacewire
    PROPERTIES
      Taste::Coordinates => "210 78" applies to spwaccess;
      Taste::Interface_Coordinates => "219 114" applies to spwaccess;
      Deployment::Configuration => "{devname ""/dev/grspwrasta0"", nodeaddr 10, corefreq 30000}";
  END spw_obj289;

  DEVICE IMPLEMENTATION spw_obj289.others EXTENDS ocarina_drivers::rasta_spacewire.pohic
  END spw_obj289.others;

  DEVICE serialleon_obj300 EXTENDS ocarina_drivers::rasta_serial
    PROPERTIES
      Taste::Coordinates => "267 104" applies to serialaccess;
      Taste::Interface_Coordinates => "273 124" applies to serialaccess;
      Deployment::Configuration => "{devname ""/dev/apburasta0"", speed b38400}";
  END serialleon_obj300;

  DEVICE IMPLEMENTATION serialleon_obj300.others EXTENDS ocarina_drivers::rasta_serial.raw
  END serialleon_obj300.others;

  --{ leonfinal_obj102 obj602 242 10 
  --This is the single board without FPGA, should 
  --have spw address 10
  --}

  SYSTEM IMPLEMENTATION leonfinal_obj102.others
    SUBCOMPONENTS
      mypart_obj190 : PROCESS mypart_obj190.others
        { Taste::Coordinates => "213 19 269 39";
           Deployment::Port_Number => 0;};
      pingee2_obj377 : SYSTEM interfaceview::IV::pingee2
        { Taste::Coordinates => "216 25 266 36" ;};
      leoncpu_obj146 : PROCESSOR ocarina_processors_leon::leon.rtems
        { Taste::Coordinates => "209 12 278 51"; };
      ram_obj234 : MEMORY ram_obj234.others
        { Taste::Coordinates => "209 53 277 70"; };
      spw_obj289 : DEVICE spw_obj289.others
        { Taste::Coordinates => "210 73 277 89";};
      serialleon_obj300 : DEVICE serialleon_obj300.others
        { Taste::Coordinates => "210 93 278 104";};

    CONNECTIONS
      --  The bus connections
      BUS ACCESS obj289_spwaccess -> spw_obj289.spwaccess;
      BUS ACCESS obj300_serialaccess -> serialleon_obj300.serialaccess;

    PROPERTIES
      -- Connexion des CPUs aux process/drivers
      Actual_Processor_Binding => (reference (leoncpu_obj146)) applies to mypart_obj190;
      Taste::APLC_Binding => (reference(mypart_obj190)) APPLIES TO pingee2_obj377;
      Actual_Processor_Binding => (reference (leoncpu_obj146)) applies to spw_obj289;
      Actual_Processor_Binding => (reference (leoncpu_obj146)) applies to serialleon_obj300;
      Actual_Memory_Binding => (reference (ram_obj234)) applies to mypart_obj190;
  END leonfinal_obj102.others;

  SYSTEM x86finalpingee_obj113
    FEATURES
      obj311_serialaccess : requires bus access ocarina_buses::serial.generic
        { Taste::Coordinates => "317 76"; };
  END x86finalpingee_obj113;

  PROCESS finalpart_obj201
  END finalpart_obj201;

  PROCESS IMPLEMENTATION finalpart_obj201.others
  END finalpart_obj201.others;

  MEMORY obj531_obj245
  END obj531_obj245;

  MEMORY IMPLEMENTATION obj531_obj245.others
  END obj531_obj245.others;

  DEVICE seriallinuxreceiver_obj311 EXTENDS ocarina_drivers::generic_serial
    PROPERTIES
      Taste::Coordinates => "317 76" applies to serialaccess;
      Taste::Interface_Coordinates => "300 124" applies to serialaccess;
      Deployment::Configuration => "{devname ""/dev/ttyUSB0"", speed b38400}";
  END seriallinuxreceiver_obj311;

  DEVICE IMPLEMENTATION seriallinuxreceiver_obj311.others EXTENDS ocarina_drivers::generic_serial.raw_receiver
  END seriallinuxreceiver_obj311.others;

  SYSTEM IMPLEMENTATION x86finalpingee_obj113.others
    SUBCOMPONENTS
      finalpart_obj201 : PROCESS finalpart_obj201.others
        { Taste::Coordinates => "320 20 376 39";
           Deployment::Port_Number => 0;};
      finalpingee_obj388 : SYSTEM interfaceview::IV::finalpingee
        { Taste::Coordinates => "326 29 371 38" ;};
      mylinux_obj157 : PROCESSOR ocarina_processors_x86::x86.linux32
        { Taste::Coordinates => "314 13 401 43"; };
      obj531_obj245 : MEMORY obj531_obj245.others
        { Taste::Coordinates => "316 47 396 66"; };
      seriallinuxreceiver_obj311 : DEVICE seriallinuxreceiver_obj311.others
        { Taste::Coordinates => "317 71 396 93";};

    CONNECTIONS
      --  The bus connections
      BUS ACCESS obj311_serialaccess -> seriallinuxreceiver_obj311.serialaccess;

    PROPERTIES
      -- Connexion des CPUs aux process/drivers
      Actual_Processor_Binding => (reference (mylinux_obj157)) applies to finalpart_obj201;
      Taste::APLC_Binding => (reference(finalpart_obj201)) APPLIES TO finalpingee_obj388;
      Actual_Processor_Binding => (reference (mylinux_obj157)) applies to seriallinuxreceiver_obj311;
      Actual_Memory_Binding => (reference (obj531_obj245)) applies to finalpart_obj201;
  END x86finalpingee_obj113.others;

  --------------
  -- Devices--
  --------------

  -----------
  -- Buses --
  -----------

  -----------------
  -- Root System --
  -----------------

  SYSTEM deploymentview
  END deploymentview;

  SYSTEM IMPLEMENTATION deploymentview.others
    SUBCOMPONENTS
      --  The processor boards
      linuxboard_obj80 : SYSTEM linuxboard_obj80.others
        { Taste::Coordinates => "5 3 88 93"; };
      leoncentral_obj91 : SYSTEM leoncentral_obj91.others
        { Taste::Coordinates => "109 8 183 98"; };
      leonfinal_obj102 : SYSTEM leonfinal_obj102.others
        { Taste::Coordinates => "205 4 284 109"; };
      x86finalpingee_obj113 : SYSTEM x86finalpingee_obj113.others
        { Taste::Coordinates => "311 5 408 99"; };
      --  The devices
      --  The buses
      serial_obj322 : BUS ocarina_buses::serial.generic
        { Taste::Coordinates => "66 112 138 136";};
      spw_obj333 : BUS ocarina_buses::spacewire.generic
        { Taste::Coordinates => "159 114 237 134";};
      serial2_obj344 : BUS ocarina_buses::serial.generic
        { Taste::Coordinates => "263 124 366 146";};
      --  The IV systems
        interfaceview_obj1375 : SYSTEM interfaceview::IV::interfaceview.others;

    CONNECTIONS
      --  The bus connections
      obj827 :BUS ACCESS serial_obj322 -> linuxboard_obj80.obj256_serialaccess
        { Taste::Coordinates => "83 83 83 98 88 98 88 112"; };
      obj648 :BUS ACCESS serial_obj322 -> leoncentral_obj91.obj267_serialaccess
        { Taste::Coordinates => "116 76 113 76 113 112"; };
      obj7839 :BUS ACCESS spw_obj333 -> leoncentral_obj91.obj278_spwaccess
        { Taste::Coordinates => "165 94 165 104 170 104 170 114"; };
      obj7928 :BUS ACCESS spw_obj333 -> leonfinal_obj102.obj289_spwaccess
        { Taste::Coordinates => "210 79 205 79 205 111 220 111 220 114"; };
      obj1477 :BUS ACCESS serial2_obj344 -> leonfinal_obj102.obj300_serialaccess
        { Taste::Coordinates => "268 104 268 114 274 114 274 124"; };
      obj1009 :BUS ACCESS serial2_obj344 -> x86finalpingee_obj113.obj311_serialaccess
        { Taste::Coordinates => "317 77 301 77 301 124"; };

    PROPERTIES
      --  The bus connection bindings
      Actual_Connection_Binding => (reference (serial_obj322)) applies to interfaceview_obj1375.obj282;
      Actual_Connection_Binding => (reference (spw_obj333)) applies to interfaceview_obj1375.obj521;
      Actual_Connection_Binding => (reference (serial2_obj344)) applies to interfaceview_obj1375.obj1232;

  END deploymentview.others;


PROPERTIES
  Taste::Coordinates => "0 0 594 420";
  Taste::interfaceView => "interfaceview.aadl";

END deploymentview::DV;
 


---------------------------------------
-- copied aadl libraries
-- TASTE requirement
-- Do not edit below this line
---------------------------------------

package ocarina_drivers_exarm_ni_6071e_analog 
 
public 
 
with Base_Types; 
with Deployment; 
 
subprogram spg_init 
properties 
   Source_Language   => C; 
   Source_Name       => "__po_hi_c_driver_exarm_ni_6071e_analog_init"; 
end spg_init; 
 
 
subprogram spg_poller 
features 
   data1  : out parameter Base_Types::Float_64; 
   data2  : out parameter Base_Types::Float_64; 
   data3  : out parameter Base_Types::Float_64; 
   data4  : out parameter Base_Types::Float_64; 
   data5  : out parameter Base_Types::Float_64; 
   data6  : out parameter Base_Types::Float_64; 
   data7  : out parameter Base_Types::Float_64; 
   data8  : out parameter Base_Types::Float_64; 
   data9  : out parameter Base_Types::Float_64; 
   data10 : out parameter Base_Types::Float_64; 
   data11 : out parameter Base_Types::Float_64; 
   data12 : out parameter Base_Types::Float_64; 
   data13 : out parameter Base_Types::Float_64; 
   data14 : out parameter Base_Types::Float_64; 
   data15 : out parameter Base_Types::Float_64; 
   data16 : out parameter Base_Types::Float_64; 
properties 
   Source_Language   => C; 
   Source_Name       => "__po_hi_c_driver_exarm_ni_6071e_analog_poller"; 
end spg_poller; 
 
 
thread thr_poller 
features 
   data1  : out data port Base_Types::Float_64; 
   data2  : out data port Base_Types::Float_64; 
   data3  : out data port Base_Types::Float_64; 
   data4  : out data port Base_Types::Float_64; 
   data5  : out data port Base_Types::Float_64; 
   data6  : out data port Base_Types::Float_64; 
   data7  : out data port Base_Types::Float_64; 
   data8  : out data port Base_Types::Float_64; 
   data9  : out data port Base_Types::Float_64; 
   data10 : out data port Base_Types::Float_64; 
   data11 : out data port Base_Types::Float_64; 
   data12 : out data port Base_Types::Float_64; 
   data13 : out data port Base_Types::Float_64; 
   data14 : out data port Base_Types::Float_64; 
   data15 : out data port Base_Types::Float_64; 
   data16 : out data port Base_Types::Float_64; 
end thr_poller; 
 
thread implementation thr_poller.i 
calls 
	mycall : { 
	  pspg : subprogram spg_poller; 
	}; 
connections 
   parameter pspg.data1 -> data1;    
   parameter pspg.data2 -> data2;    
   parameter pspg.data3 -> data3;    
   parameter pspg.data4 -> data4;    
   parameter pspg.data5 -> data5;    
   parameter pspg.data6 -> data6;    
   parameter pspg.data7 -> data7;    
   parameter pspg.data8 -> data8;    
   parameter pspg.data9 -> data9;    
   parameter pspg.data10 -> data10;    
   parameter pspg.data11 -> data11;    
   parameter pspg.data12 -> data12;    
   parameter pspg.data13 -> data13;    
   parameter pspg.data14 -> data14;    
   parameter pspg.data15 -> data15;    
   parameter pspg.data16 -> data16;  
properties 
   Period => 100 ms; 
   Dispatch_Protocol => Periodic; 
end thr_poller.i; 
 
 
abstract driver 
features 
   data1  : out data port Base_Types::Float_64; 
   data2  : out data port Base_Types::Float_64; 
   data3  : out data port Base_Types::Float_64; 
   data4  : out data port Base_Types::Float_64; 
   data5  : out data port Base_Types::Float_64; 
   data6  : out data port Base_Types::Float_64; 
   data7  : out data port Base_Types::Float_64; 
   data8  : out data port Base_Types::Float_64; 
   data9  : out data port Base_Types::Float_64; 
   data10 : out data port Base_Types::Float_64; 
   data11 : out data port Base_Types::Float_64; 
   data12 : out data port Base_Types::Float_64; 
   data13 : out data port Base_Types::Float_64; 
   data14 : out data port Base_Types::Float_64; 
   data15 : out data port Base_Types::Float_64; 
   data16 : out data port Base_Types::Float_64; 
end driver; 
 
abstract implementation driver.i 
subcomponents 
   ni6071e_analog_poller : thread thr_poller.i; 
connections 
   port ni6071e_analog_poller.data1 -> data1;    
   port ni6071e_analog_poller.data2 -> data2;    
   port ni6071e_analog_poller.data3 -> data3;    
   port ni6071e_analog_poller.data4 -> data4;    
   port ni6071e_analog_poller.data5 -> data5;    
   port ni6071e_analog_poller.data6 -> data6;    
   port ni6071e_analog_poller.data7 -> data7;    
   port ni6071e_analog_poller.data8 -> data8;    
   port ni6071e_analog_poller.data9 -> data9;    
   port ni6071e_analog_poller.data10 -> data10;    
   port ni6071e_analog_poller.data11 -> data11;    
   port ni6071e_analog_poller.data12 -> data12;    
   port ni6071e_analog_poller.data13 -> data13;    
   port ni6071e_analog_poller.data14 -> data14;    
   port ni6071e_analog_poller.data15 -> data15;    
   port ni6071e_analog_poller.data16 -> data16;  
end driver.i; 
 
end ocarina_drivers_exarm_ni_6071e_analog;


package ocarina_processors_leon 
 
public 
 
with Deployment; 
with Cheddar_Properties; 
 
processor leon 
end leon; 
 
processor implementation leon.rtems 
properties 
   Scheduling_Protocol => (Posix_1003_Highest_Priority_First_Protocol); 
   Priority_Range => 0 .. 255; 
   Cheddar_Properties::Scheduler_Quantum => 0 Ms; 
   Cheddar_Properties::Preemptive_Scheduler => true; 
   Deployment::Execution_Platform => LEON_RTEMS; 
end leon.rtems; 
 
processor implementation leon.ork 
properties 
   Deployment::Execution_Platform => LEON_ORK; 
end leon.ork; 
 
end ocarina_processors_leon;


package ocarina_drivers_exarm_ni_6071e_digital 
 
public 
 
with Base_Types; 
with Deployment; 
 
subprogram spg_init 
properties 
   Source_Language   => C; 
   Source_Name       => "__po_hi_c_driver_exarm_ni_6071e_digital_init"; 
end spg_init; 
 
 
subprogram spg_poller 
features 
   data1 : out parameter Base_Types::Unsigned_32; 
   data2 : out parameter Base_Types::Unsigned_32; 
properties 
   Source_Language   => C; 
   Source_Name       => "__po_hi_c_driver_exarm_ni_6071e_digital_poller"; 
end spg_poller; 
 
 
thread thr_poller 
features 
   data1 : out data port Base_Types::Unsigned_32; 
   data2 : out data port Base_Types::Unsigned_32; 
end thr_poller; 
 
thread implementation thr_poller.i 
calls 
	mycall : { 
	  pspg : subprogram spg_poller; 
	}; 
connections 
   parameter pspg.data1 -> data1;    
   parameter pspg.data2 -> data2;    
properties 
   Period => 100 ms; 
   Dispatch_Protocol => Periodic; 
end thr_poller.i; 
 
 
abstract driver 
features 
   data1 : out data port Base_Types::Unsigned_32; 
   data2 : out data port Base_Types::Unsigned_32; 
properties 
   Deployment::Version  => "0.1beta"; 
   Deployment::Help     => "Write your ASN.1 configuration here"; 
end driver; 
 
abstract implementation driver.i 
subcomponents 
   ni6071e_digital_poller : thread thr_poller.i; 
connections 
   port ni6071e_digital_poller.data1 -> data1;  
   port ni6071e_digital_poller.data2 -> data2;  
end driver.i; 
 
end ocarina_drivers_exarm_ni_6071e_digital;


package TCP_IP_Protocol 
 
-- This package models a TCP/IP based protocol layer for the 
-- PolyORB-HI/Ada AADL runtime. It defines the subprograms and threads 
-- to be integrated with the runtime low level interface. 
-- 
-- To configure this interface, you should use the 
-- Deployment::Configuration property with the following format:  
--     "ip <ipv4_addresse> <ipv4_port>" 
-- 
-- e.g. 
-- 
--     netif : device TCP_IP_Protocol::TCP_IP_Device 
--            {Deployment::Configuration => "ip 192.168.0.10 45678";}: 
 
public 
 
   with Generic_Native; 
   with Deployment; 
 
   ------------ 
   -- DEVICE -- 
   ------------ 
 
   -- The main entrypoint for this package is this device, it relies 
   -- on the 'Implement_As' feature that defines its full 
   -- specification. 
 
   device TCP_IP_Device 
   features 
      Ethernet_Wire : requires bus access Generic_Native::Generic_Bus.impl; 
      -- Connection to the remote node     
 
   end TCP_IP_Device; 
 
   device implementation TCP_IP_Device.impl 
   properties 
      Implemented_As =>  
         classifier (TCP_IP_Protocol::Driver_TCP_IP_Protocol.impl); 
      Initialize_Entrypoint => classifier (TCP_IP_Protocol::Initialize); 
   end TCP_IP_Device.impl; 
 
   ------------ 
   -- DRIVER -- 
   ------------ 
 
   -- In AADLv2, we can model the actual implementation of a driver 
   -- using an abstract component. 
 
   abstract Driver_TCP_IP_Protocol 
   properties 
      Deployment::Version  => "0.1beta"; 
      Deployment::Help     => "Write your ASN.1 configuration here"; 
   end Driver_TCP_IP_Protocol; 
 
   abstract implementation Driver_TCP_IP_Protocol.impl 
   subcomponents 
      receiver : thread Driver_TCP_IP_Protocol_thread_receiver.impl; 
   end Driver_TCP_IP_Protocol.impl; 
 
   ------------- 
   -- THREADS -- 
   ------------- 
 
   -- This thread handles the execution logic of the protocol 
   -- stack. It relies on the previous subprograms to receive 
   -- messages. 
 
   thread Driver_TCP_IP_Protocol_thread_receiver 
       
      -- This thread is dispatched when an event is detected on the 
      -- real hardware. It then calls receive to handle the incoming 
      -- event. 
 
   properties 
      -- Initialize_Entrypoint  
      --    => classifier (TCP_IP_Protocol::Initialize_Receiver); 
      Dispatch_Protocol => Background; 
   end Driver_TCP_IP_Protocol_thread_receiver; 
 
   thread implementation Driver_TCP_IP_Protocol_thread_receiver.impl 
   calls  
      call1 : { pspg : subprogram receive; }; 
   end Driver_TCP_IP_Protocol_thread_receiver.impl; 
 
   ----------------- 
   -- SUBPROGRAMS -- 
   ----------------- 
 
   -- These subprograms model the high-level view of the TCP/IP 
   -- protocol stack. They define an API used by the stack to send and 
   -- receive data, and perform node's initialisation. 
 
   subprogram Initialize 
 
     -- Initialize the different internal resources for managing 
     -- connections on a node. This subprogram has no formal visible 
     -- parameters, but relies on well-known data structures and 
     -- variables to configure the stack. 
 
   properties 
      Source_Name => "POlyORB_HI_Drivers_Native_TCP_IP.Initialize"; 
      Source_Language => Ada; 
   end Initialize; 
 
   ------------- 
 
   subprogram Initialize_Receiver 
 
     -- Initialize the receiver thread 
 
   properties 
      Source_Name => "POlyORB_HI_Drivers_Native_TCP_IP.Initialize_Receiver"; 
      Source_Language => Ada; 
   end Initialize_Receiver; 
 
   ------------- 
 
   subprogram Receive 
 
      -- Receive data and dispatch them to the receiving entity. This 
      -- program and its sibling (send) share a common protocol, not 
      -- defined in the AADL model. 
 
   properties 
      Source_Name => "POlyORB_HI_Drivers_Native_TCP_IP.Receive"; 
      Source_Language => Ada; 
   end Receive; 
 
   ------------- 
 
   subprogram Send 
 
      -- Send data to a remote node. This program and its sibling 
      -- (receive) share a common protocol, not defined in the AADL 
      -- model. 
 
   properties 
      Source_Name => "POlyORB_HI_Drivers_Native_TCP_IP.Send"; 
      Source_Language => Ada; 
   end Send; 
 
end TCP_IP_Protocol;


package GRUART 
 
-- This package models a UART-based protocol layer for the 
-- PolyORB-HI/Ada AADL runtime, based on the GRUART chipset from 
-- AEROFlex Gaisler. It defines the subprograms and threads to be 
-- integrated with the runtime low level interface. 
-- 
-- To configure this interface, you should use the 
-- Deployment::Configuration property with the following format:  
--     "serial DEVICE BAUDS DATA_BITS PARITY STOP_BIT" 
-- 
-- e.g. 
-- 
--     uart : device GRUART::GRUART_Device 
--            {Deployment::Configuration => "serial /dev/ttyS0 9600 8 N 1" 
--  
 
public 
 
   with Generic_Bus; 
   with Deployment; 
 
   ------------ 
   -- DEVICE -- 
   ------------ 
 
   -- The main entrypoint for this package is this device, it relies 
   -- on the 'Implement_As' feature that defines its full 
   -- specification. 
 
   device GRUART_Device 
   features 
      DB9_Wire : requires bus access Generic_Bus::GenericBus.impl; 
      -- Connection to the remote node     
 
   end GRUART_Device; 
 
   device implementation GRUART_Device.impl 
   properties 
      Implemented_As =>  
         classifier (GRUART::Driver_GRUART_Protocol.impl); 
      Initialize_Entrypoint => classifier (GRUART::Initialize); 
   end GRUART_Device.impl; 
 
   ------------ 
   -- DRIVER -- 
   ------------ 
 
   -- In AADLv2, we can model the actual implementation of a driver 
   -- using an abstract component. 
 
   abstract Driver_GRUART_Protocol 
   properties 
      Deployment::Version  => "0.1beta"; 
      Deployment::Help     => "Write your ASN.1 configuration here"; 
   end Driver_GRUART_Protocol; 
 
   abstract implementation Driver_GRUART_Protocol.impl 
   subcomponents 
      receiver : thread Driver_GRUART_Protocol_thread_receiver.impl; 
   end Driver_GRUART_Protocol.impl; 
 
   ------------- 
   -- THREADS -- 
   ------------- 
 
   -- This thread handles the execution logic of the protocol 
   -- stack. It relies on the previous subprograms to receive 
   -- messages. 
 
   thread Driver_GRUART_Protocol_thread_receiver 
       
      -- This thread is dispatched when an event is detected on the 
      -- real hardware. It then calls receive to handle the incoming 
      -- event. 
 
   properties 
      Dispatch_Protocol => Background; 
      Priority          => 10; 
      source_stack_size => 200 KByte; 
   end Driver_GRUART_Protocol_thread_receiver; 
 
   thread implementation Driver_GRUART_Protocol_thread_receiver.impl 
   calls  
      call1 : { pspg : subprogram receive; }; 
   end Driver_GRUART_Protocol_thread_receiver.impl; 
 
   ----------------- 
   -- SUBPROGRAMS -- 
   ----------------- 
 
   -- These subprograms model the high-level view of the SpaceWire 
   -- protocol stack. They define an API used by the stack to send and 
   -- receive data, and perform node's initialisation. 
 
   subprogram Initialize 
 
     -- Initialize the different internal resources for managing 
     -- connections on a node. This subprogram has no formal visible 
     -- parameters, but relies on well-known data structures and 
     -- variables to configure the stack. 
 
   properties 
      Source_Name => "PolyORB_HI_Drivers_GRUART.Initialize"; 
      Source_Language => Ada; 
   end Initialize; 
 
   ------------- 
 
   subprogram Receive 
 
      -- Receive data and dispatch them to the receiving entity. This 
      -- program and its sibling (send) share a common protocol, not 
      -- defined in the AADL model. 
 
   properties 
      Source_Name => "PolyORB_HI_Drivers_GRUART.Receive"; 
      Source_Language => Ada; 
   end Receive; 
 
   ------------- 
 
   subprogram Send 
 
      -- Send data to a remote node. This program and its sibling 
      -- (receive) share a common protocol, not defined in the AADL 
      -- model. 
 
   properties 
      Source_Name => "PolyORB_HI_Drivers_GRUART.Send"; 
      Source_Language => Ada; 
   end Send; 
 
end GRUART;


package ocarina_drivers_udp_exarm 
 
public 
 
with Data_Model; 
with Base_Types; 
 
data protocol 
properties 
   Data_Model::Data_Representation => Struct; 
end protocol; 
 
data implementation protocol.robot 
subcomponents 
   cmd   : data Base_Types::Unsigned_32; 
   pktid : data Base_Types::Unsigned_32; 
   X1    : data Base_Types::Float_32; 
   X2    : data Base_Types::Float_32; 
   X3    : data Base_Types::Float_32; 
   Y1    : data Base_Types::Float_32; 
   Y2    : data Base_Types::Float_32; 
   Y3    : data Base_Types::Float_32; 
   Z1    : data Base_Types::Float_32; 
   Z2    : data Base_Types::Float_32; 
   Z3    : data Base_Types::Float_32; 
   P1    : data Base_Types::Float_32; 
   P2    : data Base_Types::Float_32; 
   P3    : data Base_Types::Float_32; 
   J1    : data Base_Types::Float_32; 
   J2    : data Base_Types::Float_32; 
   J3    : data Base_Types::Float_32; 
   J4    : data Base_Types::Float_32; 
   J5    : data Base_Types::Float_32; 
   J6    : data Base_Types::Float_32; 
   J7    : data Base_Types::Float_32; 
   Elbow : data Base_Types::Float_32; 
end protocol.robot; 
 
 
data implementation protocol.vr 
subcomponents 
   J1    : data Base_Types::Float_64; 
   J2    : data Base_Types::Float_64; 
   J3    : data Base_Types::Float_64; 
   J4    : data Base_Types::Float_64; 
   J5    : data Base_Types::Float_64; 
   J6    : data Base_Types::Float_64; 
   J7    : data Base_Types::Float_64; 
   J8    : data Base_Types::Float_64; 
   J9    : data Base_Types::Float_64; 
   J10    : data Base_Types::Float_64; 
   J11    : data Base_Types::Float_64; 
   J12    : data Base_Types::Float_64; 
   J13    : data Base_Types::Float_64; 
   J14    : data Base_Types::Float_64; 
   J15    : data Base_Types::Float_64; 
   J16    : data Base_Types::Float_64; 
   P1    : data Base_Types::Float_64; 
   P2    : data Base_Types::Float_64; 
   P3    : data Base_Types::Float_64; 
   X1    : data Base_Types::Float_64; 
   X2    : data Base_Types::Float_64; 
   X3    : data Base_Types::Float_64; 
   Y1    : data Base_Types::Float_64; 
   Y2    : data Base_Types::Float_64; 
   Y3    : data Base_Types::Float_64; 
   Z1    : data Base_Types::Float_64; 
   Z2    : data Base_Types::Float_64; 
   Z3    : data Base_Types::Float_64; 
end protocol.vr; 
 
 
subprogram init 
properties 
   Source_Language   => C; 
   Source_Name       => "__po_hi_driver_exarm_init"; 
end init; 
 
subprogram spg_sender 
properties 
   Source_Language   => C; 
   Source_Name       => "__po_hi_driver_exarm_send"; 
end spg_sender; 
 
abstract driver 
end driver; 
 
abstract implementation driver.i 
subcomponents 
   sender : subprogram spg_sender; 
end driver.i; 
 
end ocarina_drivers_udp_exarm;


package ocarina_types 
 
public 
 
with Data_Model; 
 
data integer 
end integer; 
 
data implementation integer.i 
properties 
   Data_Model::Data_Representation => integer; 
end integer.i; 
 
data float 
end float; 
 
data implementation float.i 
properties 
   Data_Model::Data_Representation => float; 
end float.i; 
 
data boolean 
end boolean; 
 
data implementation boolean.i 
properties 
   Data_Model::Data_Representation => boolean; 
end boolean.i; 
 
end ocarina_types;


package ocarina_drivers_rtems_ne2000 
 
public 
 
with Deployment; 
 
subprogram init 
properties 
	Source_Language   => C; 
	Source_Name       => "__po_hi_driver_rtems_ne2000_init"; 
end init; 
 
thread poller 
end poller; 
 
thread implementation poller.i 
calls 
	mycall : { 
	  pspg : subprogram spg_poller; 
	}; 
properties 
   Period => 1000ms; 
   Dispatch_Protocol => Periodic; 
end poller.i; 
 
 
subprogram spg_poller 
properties 
	Source_Language   => C; 
	Source_Name       => "__po_hi_driver_rtems_ne2000_poller"; 
end spg_poller; 
 
 
subprogram spg_sender 
properties 
	Source_Language   => C; 
	Source_Name       => "__po_hi_driver_sockets_send"; 
end spg_sender; 
 
 
abstract driver 
properties 
   Deployment::Version  => "0.1beta"; 
   Deployment::Help     => "Write your ASN.1 configuration here"; 
end driver; 
 
 
abstract implementation driver.i 
subcomponents 
--  receiver : thread       eth_sockets_ne2000_rtems_poller.i; 
   sender   : subprogram   spg_sender; 
end driver.i; 
 
end ocarina_drivers_rtems_ne2000;


package ocarina_buses 
 
public 
 
bus generic_bus 
end generic_bus; 
 
bus implementation generic_bus.i 
end generic_bus.i; 
 
bus dummy_bus 
end dummy_bus; 
 
bus implementation dummy_bus.i 
end dummy_bus.i; 
 
bus ip 
end ip; 
 
bus implementation ip.pohic 
end ip.pohic; 
 
bus implementation ip.i 
subcomponents 
   asn      : virtual bus asn1.i; 
   pohic    : virtual bus pohi.c; 
   pohiada  : virtual bus pohi.ada; 
end ip.i; 
 
bus implementation ip.pohiada 
end ip.pohiada; 
 
bus spacewire 
end spacewire; 
 
bus implementation spacewire.generic 
end spacewire.generic; 
 
bus serial 
end serial; 
 
bus implementation serial.generic 
end serial.generic; 
 
 
---------------------- 
--  Virtual buses  -- 
---------------------- 
 
virtual bus raw 
end raw; 
 
virtual bus implementation raw.i 
end raw.i; 
 
virtual bus asn1 
end asn1; 
 
virtual bus implementation asn1.i 
end asn1.i; 
 
virtual bus pohi 
end pohi; 
 
virtual bus implementation pohi.c 
end pohi.c; 
 
virtual bus implementation pohi.ada 
end pohi.ada; 
 
end ocarina_buses;


package ocarina_processors_x86 
 
public 
 
with Deployment; 
 
processor x86 
properties 
   Scheduling_Protocol => (RATE_MONOTONIC_PROTOCOL); 
   Deployment::Execution_Platform => Native; 
end x86; 
 
processor implementation x86.linux 
properties 
   Deployment::Execution_Platform => Native; 
end x86.linux; 
 
processor implementation x86.linux32 
properties 
   Deployment::Execution_Platform => Linux32; 
end x86.linux32; 
 
processor implementation x86.linux64 
properties 
   Deployment::Execution_Platform => Linux64; 
end x86.linux64; 
 
processor implementation x86.native 
properties 
   Deployment::Execution_Platform => Native; 
end x86.native; 
 
processor implementation x86.native_compcert 
properties 
   Deployment::Execution_Platform => Native_Compcert; 
end x86.native_compcert; 
 
processor implementation x86.rtems 
properties 
   Deployment::Execution_Platform => X86_RTEMS; 
end x86.rtems; 
 
processor implementation x86.linuxtaste 
properties 
   Deployment::Execution_Platform => X86_LINUXTASTE; 
end x86.linuxtaste; 
 
end ocarina_processors_x86;


package Generic_Native 
 
-- This package models a generic native platform with one generic bus.  
-- 
-- Native platforms are GNU/Linux variants, MacOS X, Solaris, Windows, 
-- ... 
 
public 
  with Deployment; 
 
  --------------- 
  -- PROCESSOR -- 
  --------------- 
 
  -- Generic_Processor is the basic description of a processor with 
  -- one bus to connect an ethernet adapter. This ethernet adapter is 
  -- used through the TCP_IP_Device defined in TCP_IP_Protocol 
  -- package. 
 
  processor Generic_Processor 
  features 
    eth0_tcp_ip : requires bus access Generic_Bus.impl; 
    -- One ethernet card, connected to the processor. It is assumed 
    -- later that it is used through a TCP/IP stack 
 
  end Generic_Processor; 
 
  processor implementation Generic_Processor.impl 
  properties 
    Deployment::Execution_Platform => Native; 
    Scheduling_Protocol => (Posix_1003_Highest_Priority_First_Protocol); 
    Priority_Range => 0 .. 255; 
  end Generic_Processor.impl; 
 
  ------------ 
  -- MEMORY -- 
  ------------ 
 
  memory Memory_Segment 
  end Memory_Segment; 
 
  memory implementation Memory_Segment.impl 
  end Memory_Segment.impl; 
 
  --------- 
  -- BUS -- 
  --------- 
 
  -- Generic bus to model connections between processors and 
  -- devices. It is not used by the code generation process, so it is 
  -- made fully generic. 
 
  bus Generic_Bus 
  end Generic_Bus; 
 
  bus implementation Generic_Bus.impl 
  end Generic_Bus.impl; 
 
end Generic_Native;package GR_CPCI_X4CV 
 
-- This package models the GR-Rasta GR-CPCI-XC4V LEON Compact-PCI 
-- Development board by AEROFlex Gaisler. 
 
public 
  with Deployment; 
  with Generic_Bus; 
   
  --------------- 
  -- PROCESSOR -- 
  --------------- 
 
  -- The Rasta board has one LEON2 processor, 3 SpW cores and several 
  -- UARTS.   
  --  
  -- SpaceWire cores and UARTS are connected to separate bus, of type 
  -- Generic_Bus.impl. 
 
  processor LEON2 
  features 
    spw_core_1 : requires bus access Generic_Bus::GenericBus.impl; 
    spw_core_2 : requires bus access Generic_Bus::GenericBus.impl; 
    spw_core_3 : requires bus access Generic_Bus::GenericBus.impl; 
    -- Three SpaceWire cores 
 
    -- XXX Add UARTS 
  end LEON2; 
 
  processor implementation LEON2.impl 
  properties 
    Deployment::Execution_Platform => LEON_ORK;  -- for using GNATforLEON 
 
    -- Information on the scheduler used by GNATforLEON 
 
    Scheduling_Protocol => (Posix_1003_Highest_Priority_First_Protocol); 
    Priority_Range => 0 .. 255; 
  end LEON2.impl; 
 
  ------------ 
  -- MEMORY -- 
  ------------ 
 
  memory Memory_Segment 
  end Memory_Segment; 
 
  memory implementation Memory_Segment.impl 
  end Memory_Segment.impl; 
 
end GR_CPCI_X4CV; 
package GRSPW 
 
-- This package models a SpaceWire-based protocol layer for the 
-- PolyORB-HI/Ada AADL runtime, based on the GRSPW chipset from 
-- AEROFlex Gaisler. It defines the subprograms and threads to be 
-- integrated with the runtime low level interface. 
-- 
-- To configure this interface, you should use the 
-- Deployment::Configuration property with the following format:  
--     "spacewire Sender_Core_id Receiver_Core_Id" 
-- 
-- e.g. 
-- 
--     spw : device GRSPW::GRSPW_Device 
--            {Deployment::Configuration => "spacewire 1 2"}; 
--  
 
public 
 
   with GR_CPCI_X4CV; 
   with Generic_Bus; 
   with Deployment; 
 
   ------------ 
   -- DEVICE -- 
   ------------ 
 
   -- The main entrypoint for this package is this device, it relies 
   -- on the 'Implement_As' feature that defines its full 
   -- specification. 
 
   device GRSPW_Device 
   features 
      LVDS_Wire : requires bus access Generic_Bus::GenericBus.impl; 
      -- Connection to the remote node     
 
   end GRSPW_Device; 
 
   device implementation GRSPW_Device.impl 
   properties 
      Implemented_As =>  
         classifier (GRSPW::Driver_GRSPW_Protocol.impl); 
      Initialize_Entrypoint => classifier (GRSPW::Initialize); 
   end GRSPW_Device.impl; 
 
   ------------ 
   -- DRIVER -- 
   ------------ 
 
   -- In AADLv2, we can model the actual implementation of a driver 
   -- using an abstract component. 
 
   abstract Driver_GRSPW_Protocol 
   properties 
      Deployment::Version  => "0.1beta"; 
      Deployment::Help     => "Write your ASN.1 configuration here"; 
   end Driver_GRSPW_Protocol; 
 
   abstract implementation Driver_GRSPW_Protocol.impl 
   subcomponents 
      receiver : thread Driver_GRSPW_Protocol_thread_receiver.impl; 
   end Driver_GRSPW_Protocol.impl; 
 
   ------------- 
   -- THREADS -- 
   ------------- 
 
   -- This thread handles the execution logic of the protocol 
   -- stack. It relies on the previous subprograms to receive 
   -- messages. 
 
   thread Driver_GRSPW_Protocol_thread_receiver 
       
      -- This thread is dispatched when an event is detected on the 
      -- real hardware. It then calls receive to handle the incoming 
      -- event. 
 
   properties 
      Dispatch_Protocol => Background; 
      Priority          => 12; 
   end Driver_GRSPW_Protocol_thread_receiver; 
 
   thread implementation Driver_GRSPW_Protocol_thread_receiver.impl 
   calls  
      call1 : { pspg : subprogram receive; }; 
   end Driver_GRSPW_Protocol_thread_receiver.impl; 
 
   ----------------- 
   -- SUBPROGRAMS -- 
   ----------------- 
 
   -- These subprograms model the high-level view of the SpaceWire 
   -- protocol stack. They define an API used by the stack to send and 
   -- receive data, and perform node's initialisation. 
 
   subprogram Initialize 
 
     -- Initialize the different internal resources for managing 
     -- connections on a node. This subprogram has no formal visible 
     -- parameters, but relies on well-known data structures and 
     -- variables to configure the stack. 
 
   properties 
      Source_Name => "PolyORB_HI_Drivers_GRSPW.Initialize"; 
      Source_Language => Ada; 
   end Initialize; 
 
   ------------- 
 
   subprogram Receive 
 
      -- Receive data and dispatch them to the receiving entity. This 
      -- program and its sibling (send) share a common protocol, not 
      -- defined in the AADL model. 
 
   properties 
      Source_Name => "PolyORB_HI_Drivers_GRSPW.Receive"; 
      Source_Language => Ada; 
   end Receive; 
 
   ------------- 
 
   subprogram Send 
 
      -- Send data to a remote node. This program and its sibling 
      -- (receive) share a common protocol, not defined in the AADL 
      -- model. 
 
   properties 
      Source_Name => "PolyORB_HI_Drivers_GRSPW.Send"; 
      Source_Language => Ada; 
   end Send; 
 
end GRSPW;


package Generic_Bus 
public 
 
  --------- 
  -- BUS -- 
  --------- 
 
  -- Generic bus to model connections between processors and 
  -- devices. It is not used by the code generation process, so it is 
  -- made fully generic. 
 
  bus GenericBus 
  end GenericBus; 
 
  bus implementation GenericBus.impl 
  end GenericBus.impl; 
 
end Generic_Bus;


package ocarina_drivers_rasta_serial 
 
public 
 
with Deployment; 
with ocarina_buses; 
with ocarina_drivers; 
 
subprogram spg_serial_poller_rasta 
properties 
	Source_Language => C; 
	Source_Name => "__po_hi_c_driver_serial_rasta_poller"; 
end spg_serial_poller_rasta; 
 
 
subprogram spg_serial_sender_rasta 
properties 
	Source_Language => C; 
	Source_Name => "__po_hi_c_driver_serial_rasta_sender"; 
end spg_serial_sender_rasta; 
 
 
 
 
subprogram spg_serial_init_rasta 
properties 
	Source_Language => C; 
	Source_Name => "__po_hi_c_driver_serial_rasta_init"; 
end spg_serial_init_rasta; 
 
 
thread serial_poller 
end serial_poller; 
 
 
thread implementation serial_poller.rasta 
calls 
	mycall : { 
	  pspg : subprogram spg_serial_poller_rasta; 
	}; 
properties 
   Period => 1000ms; 
   Dispatch_Protocol => Periodic; 
end serial_poller.rasta; 
 
abstract serial_driver 
properties 
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_serial); 
   Deployment::Version  => "0.1beta"; 
   Deployment::Help     => "Write your ASN.1 configuration here"; 
end serial_driver; 
 
abstract implementation serial_driver.rasta 
subcomponents 
   receiver_rasta_serial : thread serial_poller.rasta; 
   sender                : subprogram spg_serial_sender_rasta; 
end serial_driver.rasta; 
 
end ocarina_drivers_rasta_serial;


package ocarina_drivers 
public 
 
  with deployment; 
   
  with ocarina_buses; 
   
  with Data_Model; 
  with Base_Types; 
 
  with ocarina_drivers_leon_serial; 
   
  with ocarina_drivers_rasta_1553; 
  with ocarina_drivers_rasta_serial; 
  with ocarina_drivers_rasta_spacewire; 
  with ocarina_drivers_rtems_ne2000; 
   
  with ocarina_drivers_udp_exarm; 
  with ocarina_drivers_serial; 
   
  with ocarina_drivers_ip_pohic; 
   
  with ocarina_drivers_exarm_ni_6071e_analog; 
  with ocarina_drivers_exarm_ni_6071e_digital; 
   
  with ocarina_drivers_generic_keyboard; 
   
  with GRUART; 
  with GRSPW; 
  with TCP_IP_Protocol; 
 
  ------------------------ 
  -- Configuration Type -- 
  ------------------------ 
 
   data configuration_type_ip 
   properties 
      Type_Source_Name                 => "IP-Conf-T"; 
      Deployment::ASN1_Module_Name     => "POHICDRIVER-IP"; 
      Source_Language                  => ASN1; 
      Source_Text                      => ("/home/julien/local/include/ocarina/runtime/polyorb-hi-c/src/drivers/configuration/ip.asn" , "drivers/configuration/ip.h"); 
   end configuration_type_ip; 
 
   data configuration_type_serial 
   properties 
      Type_Source_Name              => "Serial-Conf-T"; 
      Deployment::ASN1_Module_Name  => "POHICDRIVER-UART"; 
      Source_Language               => ASN1; 
      Source_Text                   => ("/home/julien/local/include/ocarina/runtime/polyorb-hi-c/src/drivers/configuration/serial.asn", "drivers/configuration/serial.h"); 
   end configuration_type_serial; 
 
   data configuration_type_spacewire 
   properties 
      Type_Source_Name              => "Spacewire-Conf-T"; 
      Deployment::ASN1_Module_Name  => "POHICDRIVER-SPACEWIRE"; 
      Source_Language               => ASN1; 
      Source_Text                   => ("/home/julien/local/include/ocarina/runtime/polyorb-hi-c/src/drivers/configuration/spacewire.asn", "drivers/configuration/spacewire.h"); 
   end configuration_type_spacewire; 
 
  -------------- 
  -- Keyboard -- 
  -------------- 
   
  device generic_keyboard 
  features 
    key_pressed  : out data port Base_Types::Character; 
  properties 
    Deployment::Driver_Name    => "generic_keyboard"; 
    Device_Driver              => classifier (ocarina_drivers_generic_keyboard::generic_keyboard_driver.i); 
    Initialize_Entrypoint      => classifier (ocarina_drivers_generic_keyboard::spg_generic_keyboard_init); 
  end generic_keyboard; 
   
  device implementation generic_keyboard.linux 
  end generic_keyboard.linux; 
 
  
  ------------------ 
  -- RASTA SERIAL -- 
  ------------------ 
   
  device leon_serial 
  features 
    serialaccess : requires bus access ocarina_buses::serial.generic; 
  end leon_serial; 
   
  device implementation leon_serial.raw 
  properties 
    Deployment::Driver_Name    => "serial_leon"; 
    Device_Driver              => classifier (ocarina_drivers_leon_serial::serial_driver.leon); 
    Initialize_Entrypoint      => classifier (ocarina_drivers_leon_serial::spg_serial_init_leon); 
    Provided_Virtual_Bus_Class => (classifier (ocarina_buses::raw.i)); 
  end leon_serial.raw; 
 
  device implementation leon_serial.raw_sender 
  properties 
    Deployment::Driver_Name    => "serial_leon_sender"; 
    Device_Driver              => classifier (ocarina_drivers_leon_serial::serial_driver.leon_sender); 
    Initialize_Entrypoint      => classifier (ocarina_drivers_leon_serial::spg_serial_init_leon_sender); 
    Provided_Virtual_Bus_Class => (classifier (ocarina_buses::raw.i)); 
  end leon_serial.raw_sender; 
 
  ---------------- 
  -- RASTA 1553 -- 
  ---------------- 
   
  device rasta_1553 
  end rasta_1553; 
   
  device implementation rasta_1553.terminal 
  properties 
    Deployment::Driver_Name    => "1553_rasta"; 
    Device_Driver              => classifier (ocarina_drivers_rasta_1553::if1553_driver.rasta_terminal); 
    Initialize_Entrypoint      => classifier (ocarina_drivers_rasta_1553::spg_1553_init_rasta_terminal); 
    Provided_Virtual_Bus_Class => (classifier (ocarina_buses::pohi.c)); 
  end rasta_1553.terminal; 
   
  device implementation rasta_1553.controller_sender_only 
  properties 
    Deployment::Driver_Name    => "1553_rasta"; 
    Device_Driver              => classifier (ocarina_drivers_rasta_1553::if1553_driver.rasta_controller_sender_only); 
    Initialize_Entrypoint      => classifier (ocarina_drivers_rasta_1553::spg_1553_init_rasta_controller); 
    Provided_Virtual_Bus_Class => (classifier (ocarina_buses::pohi.c)); 
  end rasta_1553.controller_sender_only; 
   
  ------------------ 
  -- RASTA SERIAL -- 
  ------------------ 
   
  device rasta_serial 
  features 
    serialaccess : requires bus access ocarina_buses::serial.generic; 
  end rasta_serial; 
   
  device implementation rasta_serial.raw 
  properties 
    Deployment::Driver_Name    => "serial_rasta"; 
    Device_Driver              => classifier (ocarina_drivers_rasta_serial::serial_driver.rasta); 
    Initialize_Entrypoint      => classifier (ocarina_drivers_rasta_serial::spg_serial_init_rasta); 
    Provided_Virtual_Bus_Class => (classifier (ocarina_buses::raw.i)); 
  end rasta_serial.raw; 
 
  device implementation rasta_serial.pohiada 
  properties 
    Deployment::Driver_Name    => "serial_rasta"; 
    Implemented_As =>  classifier (GRUART::Driver_GRUART_Protocol.impl); 
    Initialize_Entrypoint => classifier (GRUART::Initialize); 
    Provided_Virtual_Bus_Class => (classifier (ocarina_buses::raw.i)); 
  end rasta_serial.pohiada; 
 
  --------------------- 
  -- RASTA SPACEWIRE -- 
  --------------------- 
 
  device rasta_spacewire 
  features 
    spwaccess : requires bus access ocarina_buses::spacewire.generic; 
  end rasta_spacewire; 
   
  device implementation rasta_spacewire.pohic 
  properties 
    Deployment::Driver_Name       => "spacewire_rasta"; 
    Device_Driver                 => classifier (ocarina_drivers_rasta_spacewire::spacewire_driver.rasta); 
    Initialize_Entrypoint         => classifier (ocarina_drivers_rasta_spacewire::spg_spacewire_init_rasta); 
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c)); 
  end rasta_spacewire.pohic; 
 
  device implementation rasta_spacewire.pohiada 
  properties 
    Deployment::Driver_Name       => "spacewire_rasta"; 
    Implemented_As =>  classifier (GRSPW::Driver_GRSPW_Protocol.impl); 
    Initialize_Entrypoint => classifier (GRSPW::Initialize); 
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c)); 
  end rasta_spacewire.pohiada; 
 
  --------------------------- 
  -- Generic serial driver -- 
  --------------------------- 
 
  device generic_serial 
  features 
    serialaccess : requires bus access ocarina_buses::serial.generic; 
  end generic_serial; 
   
  device implementation generic_serial.raw 
  properties 
    Deployment::Driver_Name       => "serial_linux"; 
    Device_Driver                 => classifier (ocarina_drivers_serial::serial_driver.linux); 
    Initialize_Entrypoint         => classifier (ocarina_drivers_serial::spg_serial_init_linux); 
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::raw.i)); 
  end generic_serial.raw; 
 
  device implementation generic_serial.raw_sender 
  properties 
    Deployment::Driver_Name       => "serial_linux_sender"; 
    Device_Driver                 => classifier (ocarina_drivers_serial::serial_driver.linux_sender); 
    Initialize_Entrypoint         => classifier (ocarina_drivers_serial::spg_serial_init_linux_sender); 
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::raw.i)); 
  end generic_serial.raw_sender; 
   
  device implementation generic_serial.raw_receiver 
  properties 
    Deployment::Driver_Name       => "serial_linux_receiver"; 
    Device_Driver                 => classifier (ocarina_drivers_serial::serial_driver.linux_receiver); 
    Initialize_Entrypoint         => classifier (ocarina_drivers_serial::spg_serial_init_linux_receiver); 
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::raw.i)); 
  end generic_serial.raw_receiver; 
 
  ------------------------------- 
  -- Generic sockets/ip driver -- 
  ------------------------------- 
 
  device generic_sockets_ip 
  features 
    thebus : requires bus access ocarina_buses::ip.i; 
  end generic_sockets_ip; 
   
  device implementation generic_sockets_ip.pohic 
  properties 
    Deployment::Driver_Name       => "sockets"; 
    Device_Driver                 => classifier (ocarina_drivers_ip_pohic::sockets_impl.i); 
    Initialize_Entrypoint         => classifier (ocarina_drivers_ip_pohic::spg_sockets_init); 
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c)); 
  end generic_sockets_ip.pohic; 
 
  device implementation generic_sockets_ip.pohiada 
  properties 
    Deployment::Driver_Name       => "socketsnew"; 
    Implemented_As => classifier (TCP_IP_Protocol::Driver_TCP_IP_Protocol.impl); 
    Initialize_Entrypoint => classifier (TCP_IP_Protocol::Initialize); 
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c)); 
  end generic_sockets_ip.pohiada; 
 
  ------------------ 
  -- RTEMS NE2000 -- 
  ------------------ 
 
  device rtems_ne2000 
  features 
    thebus : requires bus access ocarina_buses::ip.i; 
  end rtems_ne2000; 
   
  device implementation rtems_ne2000.ip_pohic 
  properties 
    Deployment::Driver_Name       => "rtems_ne2000_sockets"; 
    Device_Driver                 => classifier (ocarina_drivers_rtems_ne2000::driver.i); 
    Initialize_Entrypoint         => classifier (ocarina_drivers_rtems_ne2000::init); 
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c)); 
  end rtems_ne2000.ip_pohic; 
 
  ------------------------------------------ 
  --            Exarm UDP driver          -- 
  ------------------------------------------ 
  --  This driver is used to communicate  -- 
  --  with the exarm robot and also       -- 
  --  the Matlab simulator.               -- 
  ------------------------------------------ 
   
  device exarm_ip 
  features 
    thebus : requires bus access ocarina_buses::ip.i; 
  end exarm_ip; 
   
  device implementation exarm_ip.vr_udp 
  properties 
    Deployment::Driver_Name    => "exarm"; 
    Device_Driver              => classifier (ocarina_drivers_udp_exarm::driver.i); 
    Initialize_Entrypoint      => classifier (ocarina_drivers_udp_exarm::init); 
  end exarm_ip.vr_udp; 
   
  data exarm_protocol_data 
  end exarm_protocol_data; 
   
  data implementation exarm_protocol_data.vr extends ocarina_drivers_udp_exarm::protocol.vr 
  properties 
    Data_Model::Data_Representation => Struct; 
  end exarm_protocol_data.vr; 
   
  data implementation exarm_protocol_data.robot extends ocarina_drivers_udp_exarm::protocol.robot 
  properties 
    Data_Model::Data_Representation => Struct; 
  end exarm_protocol_data.robot; 
 
  --------------------------------------- 
  --   Devices for the Exo skeleton    -- 
  --  National Instruments PCI-6071E   -- 
  --------------------------------------- 
  --  This device is used to make data -- 
  --  acquisition of the EXARM robot.  -- 
  --------------------------------------- 
   
  device exarm_ni_6071e_analog 
  features 
    data1  : out data port Base_Types::Float_64; 
    data2  : out data port Base_Types::Float_64; 
    data3  : out data port Base_Types::Float_64; 
    data4  : out data port Base_Types::Float_64; 
    data5  : out data port Base_Types::Float_64; 
    data6  : out data port Base_Types::Float_64; 
    data7  : out data port Base_Types::Float_64; 
    data8  : out data port Base_Types::Float_64; 
    data9  : out data port Base_Types::Float_64; 
    data10 : out data port Base_Types::Float_64; 
    data11 : out data port Base_Types::Float_64; 
    data12 : out data port Base_Types::Float_64; 
    data13 : out data port Base_Types::Float_64; 
    data14 : out data port Base_Types::Float_64; 
    data15 : out data port Base_Types::Float_64; 
    data16 : out data port Base_Types::Float_64; 
  end exarm_ni_6071e_analog; 
 
  device implementation exarm_ni_6071e_analog.i 
  properties 
    Deployment::Driver_Name    => "exarm_ni_6071e_analog"; 
    Device_Driver              => classifier (ocarina_drivers_exarm_ni_6071e_analog::driver.i); 
    Initialize_Entrypoint      => classifier (ocarina_drivers_exarm_ni_6071e_analog::spg_init); 
  end exarm_ni_6071e_analog.i; 
 
  device exarm_ni_6071e_digital 
  features 
    data1  : out data port Base_Types::Unsigned_8; 
    data2  : out data port Base_Types::Unsigned_8; 
  end exarm_ni_6071e_digital; 
 
  device implementation exarm_ni_6071e_digital.i 
  properties 
    Deployment::Driver_Name    => "exarm_ni_6071e_digital"; 
    Device_Driver              => classifier (ocarina_drivers_exarm_ni_6071e_digital::driver.i); 
    Initialize_Entrypoint      => classifier (ocarina_drivers_exarm_ni_6071e_digital::spg_init); 
  end exarm_ni_6071e_digital.i; 
 
end ocarina_drivers;


package ocarina_drivers_serial 
 
public 
 
with Deployment; 
with ocarina_drivers; 
 
subprogram spg_serial_poller_linux 
properties 
	Source_Language => C; 
	Source_Name => "__po_hi_c_driver_serial_linux_poller"; 
end spg_serial_poller_linux; 
 
 
subprogram spg_serial_sender_linux 
properties 
	Source_Language => C; 
	Source_Name => "__po_hi_c_driver_serial_linux_sender"; 
end spg_serial_sender_linux; 
 
 
subprogram spg_serial_init_linux 
properties 
	Source_Language => C; 
	Source_Name => "__po_hi_c_driver_serial_linux_init"; 
end spg_serial_init_linux; 
 
subprogram spg_serial_init_linux_sender 
properties 
	Source_Language => C; 
	Source_Name => "__po_hi_c_driver_serial_linux_init_sender"; 
end spg_serial_init_linux_sender; 
 
subprogram spg_serial_init_linux_receiver 
properties 
	Source_Language => C; 
	Source_Name => "__po_hi_c_driver_serial_linux_init_receiver"; 
end spg_serial_init_linux_receiver; 
 
thread serial_poller 
end serial_poller; 
 
thread implementation serial_poller.linux 
calls 
	mycall : { 
	  pspg : subprogram spg_serial_poller_linux; 
	}; 
properties 
   Period => 1000ms; 
   Dispatch_Protocol => Periodic; 
end serial_poller.linux; 
 
 
abstract serial_driver 
properties 
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_serial); 
   Deployment::Version  => "0.1beta"; 
   Deployment::Help     => "Write your ASN.1 configuration here"; 
end serial_driver; 
 
abstract implementation serial_driver.linux 
subcomponents 
   serial_linux_receiver : thread serial_poller.linux; 
   sender                : subprogram spg_serial_sender_linux; 
end serial_driver.linux; 
 
abstract implementation serial_driver.linux_sender 
subcomponents 
   sender                : subprogram spg_serial_sender_linux; 
end serial_driver.linux_sender; 
 
 
abstract implementation serial_driver.linux_receiver 
subcomponents 
   serial_linux_receiver : thread serial_poller.linux; 
end serial_driver.linux_receiver; 
 
end ocarina_drivers_serial;


package ocarina_drivers_ip_pohic 
 
public 
with Deployment; 
with ocarina_drivers; 
 
subprogram spg_sockets_init 
properties 
	Source_Language   => C; 
	Source_Name       => "__po_hi_driver_sockets_init"; 
end spg_sockets_init; 
 
 
subprogram spg_eth_linux_sender 
properties 
	Source_Language   => C; 
	Source_Name       => "__po_hi_driver_sockets_send"; 
end spg_eth_linux_sender; 
 
subprogram implementation spg_eth_linux_sender.i 
end spg_eth_linux_sender.i; 
 
abstract sockets_impl 
properties 
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_ip); 
   Deployment::Version  => "0.1beta"; 
   Deployment::Help     => "Write your ASN.1 configuration here"; 
end sockets_impl; 
 
abstract implementation sockets_impl.i 
subcomponents 
   sender   : subprogram   spg_eth_linux_sender.i; 
end sockets_impl.i; 
 
end ocarina_drivers_ip_pohic;


package ocarina_drivers_generic_keyboard 
 
public 
 
with Base_Types; 
with Deployment; 
 
subprogram spg_generic_keyboard_init 
properties 
	Source_Language   => C; 
	Source_Name       => "__po_hi_driver_generic_keyboard_init"; 
end spg_generic_keyboard_init; 
 
 
thread keyboard_poller 
features 
   key_pressed : out data port Base_Types::Integer; 
end keyboard_poller; 
 
thread implementation keyboard_poller.i 
calls 
	mycall : { 
	  pspg : subprogram spg_generic_keyboard_poller; 
	}; 
connections 
   parameter pspg.key_pressed -> key_pressed; 
properties 
   Period => 100ms; 
   Dispatch_Protocol => Periodic; 
end keyboard_poller.i; 
 
 
subprogram spg_generic_keyboard_poller 
features 
   key_pressed : out parameter Base_Types::Integer; 
properties 
	Source_Language   => C; 
	Source_Name       => "__po_hi_driver_generic_keyboard_poller"; 
end spg_generic_keyboard_poller; 
 
abstract generic_keyboard_driver 
features 
   key_pressed : out data port Base_Types::Integer; 
properties 
   Deployment::Version  => "0.1beta"; 
   Deployment::Help     => "Write your ASN.1 configuration here"; 
end generic_keyboard_driver; 
 
 
abstract implementation generic_keyboard_driver.i 
subcomponents 
   keyboard_receiver : thread       keyboard_poller.i; 
connections 
   port keyboard_receiver.key_pressed -> key_pressed; 
end generic_keyboard_driver.i; 
 
 
end ocarina_drivers_generic_keyboard;


package Native_UART 
 
-- This package models a UART protocol layer for the PolyORB-HI/Ada 
-- AADL runtime. It defines the subprograms and threads to be 
-- integrated with the runtime low level interface. 
-- 
-- To configure this interface, you should use the 
-- Deployment::Configuration property with the following format:  
--     "serial DEVICE BAUDS DATA_BITS PARITY STOP_BIT" 
-- 
-- e.g. 
-- 
--     uart : device GRUART::GRUART_Device 
--            {Deployment::Configuration => "serial /dev/ttyS0 9600 8 N 1" 
--  
 
public 
 
   with Generic_Bus; 
   with Deployment; 
 
   ------------ 
   -- DEVICE -- 
   ------------ 
 
   -- The main entrypoint for this package is this device, it relies 
   -- on the 'Implement_As' feature that defines its full 
   -- specification. 
 
   device Native_UART_Device 
   features 
      DB9_Wire : requires bus access Generic_Bus::GenericBus.impl; 
      -- Connection to the remote node     
 
   end Native_UART_Device; 
 
   device implementation Native_UART_Device.impl 
   properties 
      Implemented_As =>  
         classifier (Native_UART::Driver_Native_UART_Protocol.impl); 
      Initialize_Entrypoint => classifier (Native_UART::Initialize); 
   end Native_UART_Device.impl; 
 
   ------------ 
   -- DRIVER -- 
   ------------ 
 
   -- In AADLv2, we can model the actual implementation of a driver 
   -- using an abstract component. 
 
   abstract Driver_Native_UART_Protocol 
   properties 
      Deployment::Version  => "0.1beta"; 
      Deployment::Help     => "Write your ASN.1 configuration here"; 
   end Driver_Native_UART_Protocol; 
 
   abstract implementation Driver_Native_UART_Protocol.impl 
   subcomponents 
      receiver : thread Driver_Native_UART_Protocol_thread_receiver.impl; 
   end Driver_Native_UART_Protocol.impl; 
 
   ------------- 
   -- THREADS -- 
   ------------- 
 
   -- This thread handles the execution logic of the protocol 
   -- stack. It relies on the previous subprograms to receive 
   -- messages. 
 
   thread Driver_Native_UART_Protocol_thread_receiver 
       
      -- This thread is dispatched when an event is detected on the 
      -- real hardware. It then calls receive to handle the incoming 
      -- event. 
 
   properties 
      Dispatch_Protocol => Background; 
      Priority          => 10; 
      source_stack_size => 200 KByte; 
   end Driver_Native_UART_Protocol_thread_receiver; 
 
   thread implementation Driver_Native_UART_Protocol_thread_receiver.impl 
   calls  
      call1 : { pspg : subprogram receive; }; 
   end Driver_Native_UART_Protocol_thread_receiver.impl; 
 
   ----------------- 
   -- SUBPROGRAMS -- 
   ----------------- 
 
   -- These subprograms model the high-level view of the SpaceWire 
   -- protocol stack. They define an API used by the stack to send and 
   -- receive data, and perform node's initialisation. 
 
   subprogram Initialize 
 
     -- Initialize the different internal resources for managing 
     -- connections on a node. This subprogram has no formal visible 
     -- parameters, but relies on well-known data structures and 
     -- variables to configure the stack. 
 
   properties 
      Source_Name => "PolyORB_HI_Drivers_Native_UART.Initialize"; 
      Source_Language => Ada; 
   end Initialize; 
 
   ------------- 
 
   subprogram Receive 
 
      -- Receive data and dispatch them to the receiving entity. This 
      -- program and its sibling (send) share a common protocol, not 
      -- defined in the AADL model. 
 
   properties 
      Source_Name => "PolyORB_HI_Drivers_Native_UART.Receive"; 
      Source_Language => Ada; 
   end Receive; 
 
   ------------- 
 
   subprogram Send 
 
      -- Send data to a remote node. This program and its sibling 
      -- (receive) share a common protocol, not defined in the AADL 
      -- model. 
 
   properties 
      Source_Name => "PolyORB_HI_Drivers_Native_UART.Send"; 
      Source_Language => Ada; 
   end Send; 
 
end Native_UART;


package ocarina_drivers_rasta_spacewire 
 
public 
 
with ocarina_buses; 
with Deployment; 
 
subprogram spg_spacewire_poller_rasta 
properties 
	Source_Language => C; 
	Source_Name => "__po_hi_c_driver_spacewire_rasta_poller"; 
end spg_spacewire_poller_rasta; 
 
subprogram spg_spacewire_sender_rasta 
properties 
	Source_Language => C; 
	Source_Name => "__po_hi_c_driver_spacewire_rasta_sender"; 
end spg_spacewire_sender_rasta; 
 
subprogram spg_spacewire_init_rasta 
properties 
	Source_Language => C; 
	Source_Name => "__po_hi_c_driver_spacewire_rasta_init"; 
end spg_spacewire_init_rasta; 
 
 
thread spacewire_poller 
end spacewire_poller; 
 
thread implementation spacewire_poller.rasta 
calls 
	mycall : { 
	  pspg : subprogram spg_spacewire_poller_rasta; 
	}; 
properties 
   Period => 1000ms; 
   Dispatch_Protocol => Periodic; 
end spacewire_poller.rasta; 
 
 
abstract spacewire_driver 
properties 
   Deployment::Version  => "0.1beta"; 
   Deployment::Help     => "Write your ASN.1 configuration here"; 
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_spacewire); 
end spacewire_driver; 
 
abstract implementation spacewire_driver.rasta 
subcomponents 
   receiver_rasta_spacewire : thread spacewire_poller.rasta; 
   sender                   : subprogram spg_spacewire_sender_rasta; 
end spacewire_driver.rasta; 
 
end ocarina_drivers_rasta_spacewire;


package ocarina_drivers_rasta_1553 
 
public 
with Deployment; 
 
subprogram spg_1553_controller_rasta 
properties 
	Source_Language   => C; 
	Source_Name       => "__po_hi_c_driver_1553_rasta_controller"; 
end spg_1553_controller_rasta; 
 
subprogram spg_1553_poller_rasta_terminal 
properties 
	Source_Language   => C; 
	Source_Name       => "__po_hi_c_driver_1553_rasta_terminal_poller"; 
end spg_1553_poller_rasta_terminal; 
 
subprogram spg_1553_sender_rasta_controller 
properties 
	Source_Language   => C; 
	Source_Name       => "__po_hi_c_driver_1553_rasta_sender_controller"; 
end spg_1553_sender_rasta_controller; 
 
subprogram spg_1553_sender_rasta_terminal 
properties 
	Source_Language   => C; 
	Source_Name       => "__po_hi_c_driver_1553_rasta_sender_terminal"; 
end spg_1553_sender_rasta_terminal; 
 
 
subprogram spg_1553_init_rasta_controller 
properties 
	Source_Language   => C; 
	Source_Name       => "__po_hi_c_driver_1553_rasta_init_controller"; 
end spg_1553_init_rasta_controller; 
 
 
subprogram spg_1553_init_rasta_terminal 
properties 
	Source_Language   => C; 
	Source_Name       => "__po_hi_c_driver_1553_rasta_init_terminal"; 
end spg_1553_init_rasta_terminal; 
 
 
 
thread if1553_poller 
end if1553_poller; 
 
thread implementation if1553_poller.rasta_terminal 
calls 
	mycall : { 
	  pspg : subprogram spg_1553_poller_rasta_terminal; 
	}; 
properties 
   Period => 2000ms; 
   Dispatch_Protocol => Periodic; 
end if1553_poller.rasta_terminal; 
 
thread if1553_controller 
end if1553_controller; 
 
thread implementation if1553_controller.rasta 
calls 
	mycall : { 
	  pspg : subprogram spg_1553_controller_rasta; 
	}; 
properties 
   Period => 4000ms; 
   Dispatch_Protocol => Periodic; 
end if1553_controller.rasta; 
 
 
 
abstract if1553_driver 
properties 
   Deployment::Version  => "0.1beta"; 
   Deployment::Help     => "Write your ASN.1 configuration here"; 
end if1553_driver; 
 
abstract implementation if1553_driver.rasta_terminal 
subcomponents 
   receiver_rasta_1553 : thread       if1553_poller.rasta_terminal; 
   sender              : subprogram   spg_1553_sender_rasta_terminal; 
end if1553_driver.rasta_terminal; 
 
abstract implementation if1553_driver.rasta_controller_sender_only 
subcomponents 
--   controller  : thread       if1553_controller.rasta; 
--   This thread (controller) should be a poller thread that 
--   gives orders to the terminal nodes to send/receive data. 
--   It should also specify the communication policy (when a terminal 
--   is authorized to send/receive data). 
 
--   We don't specify poller and receiver since this controller 
--   is just a node that sends data to a single other node. 
 
   sender      : subprogram   spg_1553_sender_rasta_controller; 
end if1553_driver.rasta_controller_sender_only; 
 
 
end ocarina_drivers_rasta_1553;


package ocarina_drivers_leon_serial 
 
public 
 
with Deployment; 
with ocarina_buses; 
with ocarina_drivers; 
 
subprogram spg_serial_poller_leon 
properties 
	Source_Language => C; 
	Source_Name => "__po_hi_c_driver_serial_leon_poller"; 
end spg_serial_poller_leon; 
 
 
subprogram spg_serial_sender_leon 
properties 
	Source_Language => C; 
	Source_Name => "__po_hi_c_driver_serial_leon_sender"; 
end spg_serial_sender_leon; 
 
subprogram spg_serial_init_leon 
properties 
	Source_Language => C; 
	Source_Name => "__po_hi_c_driver_serial_leon_init"; 
end spg_serial_init_leon; 
 
subprogram spg_serial_init_leon_sender 
properties 
	Source_Language => C; 
	Source_Name => "__po_hi_c_driver_serial_leon_init_sender"; 
end spg_serial_init_leon_sender; 
 
thread serial_poller 
end serial_poller; 
 
 
thread implementation serial_poller.leon 
calls 
	mycall : { 
	  pspg : subprogram spg_serial_poller_leon; 
	}; 
properties 
   Period => 1000ms; 
   Dispatch_Protocol => Periodic; 
end serial_poller.leon; 
 
abstract serial_driver 
properties 
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_serial); 
   Deployment::Version  => "0.1beta"; 
   Deployment::Help     => "Write your ASN.1 configuration here"; 
end serial_driver; 
 
abstract implementation serial_driver.leon 
subcomponents 
   receiver_leon_serial  : thread serial_poller.leon; 
   sender                : subprogram spg_serial_sender_leon; 
end serial_driver.leon; 
 
abstract implementation serial_driver.leon_sender 
subcomponents 
   sender                : subprogram spg_serial_sender_leon; 
end serial_driver.leon_sender; 
 
 
end ocarina_drivers_leon_serial;


